id: ast-grep-go-security-insecure-cgi-module
valid:
  - |
    package main

    import (
    	"crypto/cipher"
    	"crypto/des"
    	"crypto/md5"
    	"crypto/rand"
    	"crypto/rc4"
    	"crypto/sha1"
    	"encoding/hex"
    	"fmt"
    	"io"
    	"os"
    )

    func goodExample() {
    	// This should not trigger the rule - no cgi usage
    	block, err := des.NewCipher([]byte("sekritz"))
    	if err != nil {
    		panic(err)
    	}
    	plaintext := []byte("I CAN HAZ SEKRIT MSG PLZ")
    	ciphertext := make([]byte, des.BlockSize+len(plaintext))
    	iv := ciphertext[:des.BlockSize]
    	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
    		panic(err)
    	}
    	stream := cipher.NewCFBEncrypter(block, iv)
    	stream.XORKeyStream(ciphertext[des.BlockSize:], plaintext)
    	fmt.Println("Secret message is: %s", hex.EncodeToString(ciphertext))
    }
  - |
    package main
    import "os"
    func anotherGoodExample() {
    	for _, arg := range os.Args {
    		// This should not trigger the rule - no cgi usage
    		fmt.Printf("%x - %s\n", md5.Sum([]byte(arg)), arg)
    	}
    }
  - |
    package main

    import (
    	"crypto/rc4"
    	"encoding/hex"
    	"fmt"
    )

    func thirdGoodExample() {
    	// This should not trigger the rule - no cgi usage
    	cipher, err := rc4.NewCipher([]byte("sekritz"))
    	if err != nil {
    		panic(err)
    	}
    	plaintext := []byte("I CAN HAZ SEKRIT MSG PLZ")
    	ciphertext := make([]byte, len(plaintext))
    	cipher.XORKeyStream(ciphertext, plaintext)
    	fmt.Println("Secret message is: %s", hex.EncodeToString(ciphertext))
    }
  - |
    package main

    import (
    	"crypto/sha1"
    	"fmt"
    	"os"
    )

    func fourthGoodExample() {
    	for _, arg := range os.Args {
    		// This should not trigger the rule - no cgi usage
    		fmt.Printf("%x - %s\n", sha1.Sum([]byte(arg)), arg)
    	}
    }
invalid:
  - |
    package main

    import (
    	"net/http"
    	"net/http/cgi"
    )

    // First bad example - uses cgi.Serve
    func badExample() {
    	// ruleid: insecure-cgi-module
    	// This should trigger the rule - uses net/http/cgi import and cgi.Serve
    	cgi.Serve(http.FileServer(http.Dir("/usr/share/doc")))
    }
  - |
    package main

    import (
    	"net/http"
    	"net/http/cgi"
    )

    // Second bad example - uses cgi.Serve with different parameters
    func anotherBadExample() {
    	// ruleid: insecure-cgi-module
    	// This should also trigger the rule - uses cgi.Serve function
    	cgi.Serve(http.FileServer(http.Dir("/tmp")))
    }