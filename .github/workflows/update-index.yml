name: Update Rule Index

on:
  push:
    branches:
      - main
    paths:
      - 'ast-grep/rules/**/*.yml'

jobs:
  update-index:
    runs-on: ubuntu-latest
    name: Regenerate index.json with new rules

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Generate index.json
        run: |
          echo "ðŸ” Scanning rules directory for YAML files..."

          # Find all rule YAML files
          RULE_FILES=$(find ast-grep/rules -name "*.yml" -type f)

          if [ -z "$RULE_FILES" ]; then
            echo "âŒ No rule files found!"
            exit 1
          fi

          echo "ðŸ“‹ Found rule files:"
          echo "$RULE_FILES"
          echo ""

          # Use jq to build the JSON object incrementally
          JSON_RULES="[]"

          for rule_file in $RULE_FILES; do
            echo "ðŸ“– Processing rule: $rule_file"

            # Check if file exists and is readable
            if [ ! -f "$rule_file" ]; then
              echo "âŒ Rule file not found: $rule_file"
              continue
            fi

            # Extract metadata using grep and sed for better reliability
            RULE_ID=$(grep '^id:' "$rule_file" | head -1 | sed 's/id: *//' | tr -d ' ')
            RULE_LANGUAGE=$(grep '^language:' "$rule_file" | head -1 | sed 's/language: *//' | tr -d ' ')
            RULE_MESSAGE=$(grep '^message:' "$rule_file" | head -1 | sed 's/message: *//' | sed 's/^"\(.*\)"$/\1/' | sed "s/'/\\'/g")
            RULE_SEVERITY=$(grep '^severity:' "$rule_file" | head -1 | sed 's/severity: *//' | tr -d ' ')

            # Extract metadata fields
            METADATA_AUTHOR=$(grep -A 10 '^metadata:' "$rule_file" | grep 'author:' | head -1 | sed 's/.*author: *//' | tr -d '"' | tr -d "'" | tr -d ' ')
            METADATA_DESCRIPTION=$(grep -A 10 '^metadata:' "$rule_file" | grep 'description:' | head -1 | sed 's/.*description: *//' | sed 's/^"\(.*\)"$/\1/' | sed "s/'/\\'/g")
            METADATA_TAGS=$(grep -A 10 '^metadata:' "$rule_file" | grep 'tags:' | head -1 | sed 's/.*tags: *//' | tr -d '"' | tr -d "'" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

            # Get relative path for the rule file
            RULE_PATH=$(echo "$rule_file" | sed 's|^ast-grep/||')

            # Create a JSON object for the current rule
            RULE_JSON=$(jq -n \
              --arg id "$RULE_ID" \
              --arg tool "ast-grep" \
              --arg path "$RULE_PATH" \
              --arg language "$RULE_LANGUAGE" \
              --arg author "$METADATA_AUTHOR" \
              --arg message "$RULE_MESSAGE" \
              --arg severity "$RULE_SEVERITY" \
              --arg description "$METADATA_DESCRIPTION" \
              '{id: $id, tool: $tool, path: $path, language: $language, author: $author, message: $message, severity: $severity, description: $description}')

            # Create a JSON array from the comma-separated tags
            TAGS_JSON=$(echo "$METADATA_TAGS" | jq -R 'split(",") | map(gsub("^[[:space:]]+|[[:space:]]+$"; ""))')

            # Add the tags array to the rule object
            RULE_JSON=$(echo "$RULE_JSON" | jq --argjson tags "$TAGS_JSON" '. + {tags: $tags}')

            # Add the rule object to the main rules array
            JSON_RULES=$(echo "$JSON_RULES" | jq ". + [$RULE_JSON]")

            echo "  ID: $RULE_ID"
            echo "  Language: $RULE_LANGUAGE"
            echo "  Path: $RULE_PATH"
            echo "  Author: $METADATA_AUTHOR"
            echo "  Tags: $TAGS_JSON"
            echo ""
          done

          # Create the final index object
          FINAL_JSON=$(jq -n --argjson rules "$JSON_RULES" '{version: 1, rules: $rules}')

          # Write the pretty-printed JSON to the index file
          echo "$FINAL_JSON" | jq '.' > index.json

          echo "âœ… Generated index.json with $(echo "$RULE_FILES" | wc -l) rules"

      - name: Validate generated index.json
        run: |
          echo "ðŸ” Validating generated index.json..."
          if ! jq empty index.json 2>/dev/null; then
            echo "âŒ Invalid JSON generated:"
            cat index.json
            exit 1
          fi

          RULE_COUNT=$(jq '.rules | length' index.json)
          echo "âœ… Valid JSON with $RULE_COUNT rules"

      - name: Commit and push index.json
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Check if index.json has changed
          if git diff --quiet index.json; then
            echo "â„¹ï¸ No changes to index.json"
          else
            echo "ðŸ“ Committing updated index.json..."
            git add index.json
            git commit -m "ðŸ¤– Update index.json with latest rules

            Generated from $(git log --oneline -1 | cut -d' ' -f1) - $(git log --oneline -1 | cut -f2-)
            "
            git push

            echo "âœ… Successfully updated index.json"
          fi

      - name: Summary
        run: |
          RULE_COUNT=$(grep -c '"id":' index.json 2>/dev/null || echo "0")
          echo "## âœ… Index Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“Š **Index contains $RULE_COUNT rules**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Recent Rules:" >> $GITHUB_STEP_SUMMARY
          grep -E '"id"|"language"|"message"' index.json | grep -v '"tool"' | head -15 | sed 's/.*"id": "\([^"]*\)".*/  - \1/' | sed 's/.*"language": "\([^"]*\)".*/    (\1)/' | sed 's/.*"message": "\([^"]*\)".*/    \1/' | head -10 >> $GITHUB_STEP_SUMMARY || echo "  (Error reading rules)" >> $GITHUB_STEP_SUMMARY